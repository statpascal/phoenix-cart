;bitboard logical operations routines
;bitboard is an array[0..3] of integer

        .relproc bitnot,2
;complements a bitboard
;usage: bitnot(var bitboard1[0], bitboard2[0])
;the complement of bitboard1 will be stored in bitboard2
        
        .def    iloc,disp,flag,dbyte,trimray
        .def    bitchk,subrtn,subrtn1,bittab
        .def    cumdisp,zero,vflag,pcount,oflag
        .def    l_edge,r_edge
        mov     *r10+,r6        ;get pointer to bitboard2
        mov     *r10,r5         ;get pointer to bitboard1
        mov     *r5+,r4         ;protect content of bitboard1
        inv     r4              ;complement bitboard1
        mov     r4,*r6+         ;store in bitboard2
        mov     *r5+,r4
        inv     r4
        mov     r4,*r6+
        mov     *r5+,r4
        inv     r4
        mov     r4,*r6+
        mov     *r5,r4
        inv     r4
        mov     r4,*r6
        b       *r11

iloc    .word
disp    .word
cumdisp .word
flag    .word
vflag   .word   0
oflag   .word   
zero    .word   0
subrtn  .word
subrtn1 .word
pcount  .word
bittab  .byte   128,64,32,16,8,4,2,1
dbyte   .byte
        .align  2

;trim a ray to empty squares
trimray mov     r11,@subrtn1
nxtsqr  a       @disp,@cumdisp
        mov     @cumdisp,r4
        ci      r4,0            ;check if location off bottom of board
        jlt     done
        ci      r4,63           ;check if location off top of board
        jgt     done
        bl      @bitchk         ;check value of bit at new location
        ci      r5,0            ;is bit value 0?
        jne     next
        c       @flag,@zero     ;check if zero flag already set
        jne     sidebit
        inc     @flag           ;set zero flag
        c       @oflag,@zero    ;check of opponent flag set
        jeq     sidebit
        clr     r5              ;set the displacement bit
        movb    *r4,r5
        inv     r6
        socb    r6,r5
        movb    r5,*r4
        inv     r6
sidebit c       @vflag,@zero
        jne     nxtsqr
        clr     r4
        movb    @dbyte,r4       ;get byte displacement
        swpb    r4
        a       r2,r4           ;point to byte in side bitboard
        clr     r5
        movb    *r4,r5
        szcb    r6,r5           ;r5 now has value of sides bitboard bit
        ci      r5,0
        jeq     nxtsqr
        jmp     done
next    c       @flag,@zero
        jeq     sidebit
        inv     r6
        clr     r5
        movb    *r4,r5
        szcb    r6,r5
        movb    r5,*r4          ;clear the displacement bit
        inv     r6
        jmp     sidebit
done    mov     @subrtn1,r11
        b       *r11

;return value of displacement bit in r5
;r4 has the bitboard position
bitchk  clr     r7              ;clear index to bittab
        mov     r4,r5           ;point to displacement square
        mov     r5,r6
        srl     r5,3            ;calculate byte displacement (DIV 8)
        mov     r5,r4           ;save byte displacement
        sla     r5,3            ;multiply by 8
        jmp     trgchk
nxtbit  inc     r5              ;add a bit to the byte
        inc     r7              ;increment bit mask table index
trgchk  c       r5,r6           ;are we at the displacement bit?
        jne     nxtbit
        swpb    r4
        movb    r4,@dbyte       ;store byte displacement
        swpb    r4
        a       r3,r4           ;point to byte in bitboard
        clr     r5
        movb    *r4,r5          ;get displacement byte content
        clr     r6
        movb    @bittab(r7),r6
        inv     r6
        szcb    r6,r5           ;high byte of r5 has value of displacement bit
        b       *r11
        
;check if at left edge of board
l_edge  mov     r11,@subrtn1
        clr     r5
        mov     @iloc,r4
        ci      r4,0
        jeq     atedge
        ci      r4,8
        jeq     atedge
        ci      r4,16
        jeq     atedge
        ci      r4,24
        jeq     atedge
        ci      r4,32
        jeq     atedge
        ci      r4,40
        jeq     atedge
        ci      r4,48
        jeq     atedge
        ci      r4,56
        jeq     atedge
        jmp     notedge
atedge  inc     r5
notedge mov     @subrtn1,r11
        b       *r11
        
;check if at right edge of board
r_edge  mov     r11,@subrtn1
        clr     r5
        mov     @iloc,r4
        ci      r4,7
        jeq     atedge1
        ci      r4,15
        jeq     atedge1
        ci      r4,23
        jeq     atedge1
        ci      r4,31
        jeq     atedge1
        ci      r4,39
        jeq     atedge1
        ci      r4,47
        jeq     atedge1
        ci      r4,55
        jeq     atedge1
        ci      r4,63
        jeq     atedge1
        jmp     noedge
atedge1 inc     r5
noedge  mov     @subrtn1,r11
        b       *r11

        .relproc   bitand,3
;logically AND 2 bitboards
;usage: bitand(var bitboard1[0], bitboard2[0], bitboard3[0])
;bitboard1 and bitboard2 are ANDed and the result placed in bitboard3

        mov     *r10+,r7        ;get pointer to bitboard3
        mov     *r10+,r6        ;get pointer to bitboard2
        mov     *r10,r5         ;get pointer to bitboard1
        mov     *r5+,r3         ;protect contents of bitboard1 and bitboard2
        mov     *r6+,r4
        inv     r3              ;AND bitboard1 with bitboard 2
        szc     r3,r4           ;inv then szc = and
        mov     r4,*r7+         ;save result in bitboard3
        mov     *r5+,r3
        mov     *r6+,r4
        inv     r3
        szc     r3,r4
        mov     r4,*r7+
        mov     *r5+,r3
        mov     *r6+,r4
        inv     r3
        szc     r3,r4
        mov     r4,*r7+
        mov     *r5,r3
        mov     *r6,r4
        inv     r3
        szc     r3,r4
        mov     r4,*r7
        b       *r11

        .relproc   bitor,3
;logicaly OR two bitboards
;usage: bitor(bitboard1[0], bitboard2[0], bitboard3[0])
;bitboard1 and bitboard2 are ORed and the result placed in bitboard3

        mov     *r10+,r7        ;get pointer to bitboard3
        mov     *r10+,r6        ;get pointer to bitboard2
        mov     *r10,r5         ;get pointer to bitboard1
        mov     *r6+,r3         ;protect contents of bitboard2
        soc     *r5+,r3         ;or bitboard1 and bitboard2
        mov     r3,*r7+         ;store result in bitboard3
        mov     *r6+,r3
        soc     *r5+,r3
        mov     r3,*r7+
        mov     *r6+,r3
        soc     *r5+,r3
        mov     r3,*r7+
        mov     *r6,r3
        soc     *r5,r3
        mov     r3,*r7
        b       *r11

        .relproc   bitxor,3
;logically XOR two bitboards
;usage: bitxor(var bitboard1[0], bitboard2[0], bitboard3[0])
;bitboard1 and bitboard2 are XORed and the result placed in bitboard3

        mov     *r10+,r7        ;get pointer to bitboard3
        mov     *r10+,r6        ;get pointer to bitboard2
        mov     *r10,r5         ;get pointer to bitboard1
        mov     *r6+,r4         ;xor bitboard1 and bitboard2
        xor     *r5+,r4
        mov     r4,*r7+         ;store result in bitboard3
        mov     *r6+,r4
        xor     *r5+,r4
        mov     r4,*r7+
        mov     *r6+,r4
        xor     *r5+,r4
        mov     r4,*r7+
        mov     *r6,r4
        xor     *r5,r4
        mov     r4,*r7
        b       *r11
        
        .relproc   rshift,3
;logically right shift a bitboard
;usage: rshift(var bitboard1[0], bitboard2[0]; intnum)
;bitboard1 is logically right shifted intnum times
;the result is placed in bitboard2

        mov     *r10+,r5        ;get number of shifts
        mov     *r10+,r7        ;get pointer to bitboard2
        mov     *r10,r6         ;get pointer to bitboard1
        mov     *r6+,r4         ;transfer bitboard1 to regs 4-1
        mov     *r6+,r3
        mov     *r6+,r2
        mov     *r6,r1
nxtshft srl     r1,1            ;right shift r1-r4 sequentially 1 position
        srl     r2,1
        jnc     notset1         ;transfer carry bit to previous register if set
        ori     r1,8000h
notset1 srl     r3,1
        jnc     notset2
        ori     r2,8000h
notset2 srl     r4,1
        jnc     notset3
        ori     r3,8000h
notset3 dec     r5              ;done with shifts?
        jne     nxtshft
        mov     r4,*r7+         ;save shifted bitboard1 to bitboard2
        mov     r3,*r7+
        mov     r2,*r7+
        mov     r1,*r7
        b       *r11

        .relproc   lshift,3
;logically left shift a bitboard
;usage: lshift(var bitboard1[0], bitboard2[0]; intnum)
;bitboard1 is logically left shifted intnum times
;the result is placed in bitboard2

        mov     *r10+,r5        ;get number of shifts
        mov     *r10+,r7        ;get pointer to bitboard2
        mov     *r10,r6         ;get pointer to bitboard1
        mov     *r6+,r4         ;transfer bitboard1 to r4-r1
        mov     *r6+,r3
        mov     *r6+,r2
        mov     *r6,r1
newshft sla     r4,1            ;left shift r4-r1 in sequence 1 position
        sla     r3,1
        jnc     nocar1          ;transfer carry bit to next register if set
        ori     r4,0001h
nocar1  sla     r2,1
        jnc     nocar2
        ori     r3,0001h
nocar2  sla     r1,1
        jnc     nocar3
        ori     r2,0001h
nocar3  dec     r5              ;done with shifts?
        jne     newshft
        mov     r4,*r7+         ;save shifted bitboard1 to bitboard2
        mov     r3,*r7+
        mov     r2,*r7+
        mov     r1,*r7
        b       *r11
        
        .relproc   bittrim,5
;trim sliding pieces movement rays
;rays will be trimmed to first empty square
;usage: BitTrim(bitboard1, bitboard2, varintloc, varinttype, flag)
;bitboard1 is untrimmed movement bitboard
;bitboard2 is the sides bitboard (left and right sides set to 1)
;intloc is starting position of sliding piece
;inttype is piece type : r=8, b=24, q=32
;flag = 1 when trimming for opponent pieces, otherwise 0 
        .ref    iloc,disp,flag,dbyte,trimray
        .ref    bitchk,subrtn1,bittab,l_edge,r_edge
        .ref    cumdisp,zero,subrtn,vflag,oflag
        mov     r11,@subrtn
        mov     *r10+,@oflag    ;get opponent flag value
        mov     *r10+,r0        ;get pointer to piece type
        mov     *r10+,r1        ;get pointer to intloc
        mov     *r10+,r2        ;get pointer to bitboard2
        mov     *r10,r3         ;get pointer to bitboard1
        mov     *r1,r4          ;get piece location
        mov     r4,@iloc        ;save piece location
        mov     r4,@cumdisp
        mov     *r0,r5          ;get value of piece type
        ci      r5,24           ;check if bishop
        jeq     bishop
        ;up ray
        clr     @flag
        inc     @vflag
        li      r5,8            ;displacement value
        mov     r5,@disp        
        bl      @trimray
        ;down ray
        clr     @flag
        mov     @iloc,@cumdisp
        li      r5,-8
        mov     r5,@disp
        bl      @trimray
        ;left ray
        clr     @flag
        clr     @vflag
        bl      @l_edge         ;check if already at left edge
        ci      r5,0
        jne     rray
        mov     @iloc,@cumdisp
        li      r5,-1
        mov     r5,@disp
        bl      @trimray
        ;right ray
rray    clr     @flag
        bl      @r_edge         ;check if already at right edge
        ci      r5,0
        jne     isrook
        mov     @iloc,@cumdisp
        li      r5,1
        mov     r5,@disp
        bl      @trimray
isrook  mov     *r0,r5
        ci      r5,8
        jeq     finish
        ;left upper ray
bishop  clr     @flag
        bl      @l_edge         ;check if already at left edge
        ci      r5,0
        jne     rcheck
        mov     @iloc,@cumdisp
        li      r5,7
        mov     r5,@disp
        bl      @trimray
        ;left lower ray
        clr     @flag
        mov     @iloc,@cumdisp
        li      r5,-9
        mov     r5,@disp
        bl      @trimray
rcheck  ;right upper ray
        clr     @flag
        bl      @r_edge         ;check if already at right edge
        ci      r5,0
        jne     finish
        mov     @iloc,@cumdisp
        li      r5,9
        mov     r5,@disp
        bl      @trimray
        ;right lower ray
        clr     @flag
        mov     @iloc,@cumdisp
        li      r5,-7
        mov     r5,@disp
        bl      @trimray
finish  mov     @subrtn,r11
        b       *r11

        .relproc   bitpos,2
;extract the board positions of each piece on the board
;usage: bitpos(bitboard, intarray)
;intarray will have number of pieces at index 0
;and a sequential list of positions for each piece
;starting at index 1 and board position 
        .ref    bitchk,bittab,subrtn,pcount
        mov     r11,@subrtn
        mov     *r10+,r1        ;get array pointer
        mov     *r10, r3        ;get bitboard pointer
        clr     r0              ;initialize position marker
        clr     r4              ;initialize board position
        clr     @pcount         ;initialize piece counter
        mov     r1,r2           ;save array pointer
        inct    r1              ;point to array index 1
nextpos bl      @bitchk         ;get value of bit in msb of r5
        ci      r5,0
        jeq     nopiece
        mov     r0,*r1+         ;store piece position in array
        inc     @pcount         ;update piece counter
nopiece inc     r0
        mov     r0,r4
        ci      r4,63           ;check if end of bitboard reached
        jgt     donebrd
        jmp     nextpos
donebrd mov     @pcount,*r2     ;store pieces number in array
        mov     @subrtn,r11
        b       *r11
        
        .end
        
        
