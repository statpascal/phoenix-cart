unit pmove;

interface
uses {$U chesslib.code} globals;

procedure PlayerMove(var playMove : moverec; lastMove : moverec;
                     pturn : integer);
procedure Utility(var switch : integer);

implementation
uses {$U interface.code} trimprocs, ui;

procedure UpdateBoard(gBase, gOffset : integer);

var
 offset : integer;
 buffer : array[0..59] of integer;

begin
 startPage := gBase;
 dataSize := 120;
 offset := gOffset;
 DataOps(2, startPage, dataSize, offset, buffer);
 startPage := BASE;
 offset := WPO;
 DataOps(1, startPage, dataSize, offset, buffer);

 BoardDisplay;
 gotoxy(0, 2);
 if gameSide = 0 then
  write('turn: white')
 else
  write('turn: black');

 gotoxy(10, 1);
 write('move: ', gameMove);

 gotoxy(20, 1);
 if cWarning = 1 then
  write(chr(7), chr(7), 'check!')
 else
  write('      ');

 dataSize := 8;
end; (* UpdateBoard *)

procedure ClearFields;

var
 y : integer;

begin
 for y := 3 to 13 do
  begin
   gotoxy(20, y);
   write('                ');
  end;
end; (* ClearFields *)

{$I utility.text}

procedure playerMove;

label 
 1, 2;

var
 i, j, k, iLoc, eLoc, initOffset, offset, offset1, ans : integer;
 sideOffset, offset2, offset3, offset4, switchState : integer;
 validSq, foundFlag : boolean;

begin
 turn := pturn;
 startPage := BASE;
 dataSize := 8;

 {back up current game state}
 for i := 0 to 14 do
  begin
   offset := WPO + (i * 8);
   DataOps(2, startPage, dataSize, offset, bit1);
   offset := TWPO + (i * 8);
   DataOps(1, startPage, dataSize, offset, bit1);
  end;

 1:
 gotoxy(20, 6);
 write(chr(7), 'enter move');
 gotoxy(20, 7);
 write('              ');
 gotoxy(20, 7);
 {get start square}
 validSq := FALSE;
 repeat
  gotoxy(20, 7);
  write('from: ');
  repeat
   ans := GetKey;
  until ans in[65..72, 84, 85];

  {utility menu}
  if ans = 85 then
   begin
    Utility(switchState);
    if switchState = 1 then
     if humanSide <> gameSide then
      exit(PlayerMove);
    if pieceCount = -1 then
     exit(PlayerMove);
    goto 1;
   end;

  iLoc := ans - 65;
  write(chr(ans));
  repeat
   ans := GetKey;
  until ans in[49..56, 82];
  if ans = 82 then
   goto 1;
  iLoc := iLoc + ((ans - 49) * 8);
  write(chr(ans));

  {validate square}
  if turn = 0 then
   begin
    offset := WPIECES;
    sideOffset := offset;
   end
  else
   begin
    offset := BPIECES;
    sideOffset := offset;
   end;

  DataOps(2, startPage, dataSize, offset, bit1);
  offset := PIECELOC + (iLoc * 8);
  DataOps(2, startPage, dataSize, offset, bit2);
  BitAnd(bit1, bit2, bit3);
  if not(IsClear(bit3)) then
   validSq := TRUE
  else
   write(chr(7), chr(8), chr(8));
   write('  ', chr(8), chr(8));
 until validSq = TRUE;

 playMove.startSq := iLoc;
 {determine piece type}
 i := 0;
 foundFlag := FALSE;
 if turn = 0 then
  initOffset := WPO
 else
  initOffset := BPO;
 repeat
  offset:= initOffset + i;
  DataOps(2, startPage, dataSize, offset, bit3);
  BitAnd(bit3, bit2, bit3);
  if not(IsClear(bit3)) then
   begin
    foundFlag := TRUE;
    playMove.id := i;
   end
  else
   i := i + 8
 until foundFlag = TRUE;

 2:
 {get end square}
 validSq := FALSE;
 repeat
  gotoxy(30, 7);
  write('to: ');
  repeat
   ans := GetKey;
  until ans in[65..72, 82]; 
  if ans = 82 then
   goto 1;
  eLoc := ans - 65;
  write(chr(ans));
  repeat
   ans := GetKey;
  until ans in[49..56, 82];
  if ans = 82 then 
   goto 1;
  eLoc := eLoc + ((ans - 49) * 8);
  write(chr(ans));

  {validate end square}
  offset := PIECELOC + (eLoc * 8);
  DataOps(2, startPage, dataSize, offset, bit3);
  BitAnd(bit1, bit3, bit1);
  if IsClear(bit1) then
   begin
    {check if castling move}
    if (playMove.id = 40) and (abs(iLoc - eLoc) = 2) then
     begin
      {$I castle.text}
     end
    else
     begin
      {trim movement to blocks}
      Trim(playMove.id, iLoc, sideOffset, lastMove, bit2);

      offset := PIECELOC + (eLoc * 8);
      DataOps(2, startPage, dataSize, offset, bit3);
      BitAnd(bit3, bit2, bit3);
      if not(IsClear(bit3)) then
       validSq := TRUE;
     end;
   end;

  if not(validSq) then
   begin
    write(chr(7), chr(8), chr(8));
    write('  ', chr(8), chr(8));
   end;
 until validSq = TRUE;
 playMove.endSq := eLoc;

 {verify if own king in check after move}
 {update appropriate piece bitboard with move}
 offset := PIECELOC + (iLoc * 8);
 DataOps(2, startPage, dataSize, offset, bit1);
 offset := PIECELOC + (eLoc * 8);
 DataOps(2, startPage, dataSize, offset, bit3);
 BitNot(bit1, bit1);
 offset := APIECES;
 DataOps(2, startPage, dataSize, offset, bit4);
 BitAnd(bit1, bit4, bit4);
 BitOr(bit3, bit4, bit4);
 DataOps(1, startPage, dataSize, offset, bit4);

 if turn = 0 then
  begin
   offset := WPO + playMove.id;
   offset1 := WPIECES;
   offset2 := BPIECES;
  end
 else
  begin
   offset := BPO + playMove.id;
   offset1 := BPIECES;
   offset2 := WPIECES;
  end;
 DataOps(2, startPage, dataSize, offset, bit4);
 BitAnd(bit1, bit4, bit4);
 BitOr(bit3, bit4, bit4);
 DataOps(1, startPage, dataSize, offset, bit4);
 DataOps(2, startPage, dataSize, offset1, bit4);
 BitAnd(bit1, bit4, bit4);
 BitOr(bit3, bit4, bit4);
 DataOps(1, startPage, dataSize, offset1, bit4);

 {remove any potential captures from opposite boards}
 DataOps(2, startPage, dataSize, offset2, bit4);
 BitNot(bit3, bit3);
 BitAnd(bit3, bit4, bit4);
 DataOps(1, startPage, dataSize, offset2, bit4);
 i := 0;
 if turn = 0 then 
  offset := BPO
 else
  offset := WPO;
 repeat
  offset1 := offset + i;
  DataOps(2, startPage, dataSize, offset1, bit1);
  BitAnd(bit1, bit3, bit1);
  DataOps(1, startPage, dataSize, offset1, bit1);
  i := i + 8;
 until i > 40;

 {generate combined trimmed movement bitboards}
 CombineTrim(bit3, bit5, lastMove);

 {verify if king in check}
 if turn = 0 then
  offset := WKO
 else
  offset := BKO;
 DataOps(2, startPage, dataSize, offset, bit1);

 if turn = 0 then
  BitAnd(bit1, bit5, bit1)
 else
  BitAnd(bit1, bit3, bit1);

 if not(IsClear(bit1)) then
 {king in check. undo move}
  begin
   for i := 0 to 14 do
    begin
     offset := TWPO + (i * 8);
     DataOps(2, startPage, dataSize, offset, bit1);
     offset := WPO + (i * 8);
     DataOps(1, startPage, dataSize, offset, bit1);
    end;
   validSq := FALSE;
   write(chr(7), chr(8), chr(8), '  ', chr(8), chr(8));
   goto 2;
  end;
end; {playerMove}

end.
